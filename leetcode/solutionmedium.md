### 134. 加油站

不会

### 11. 盛最多水的容器

对撞指针，移动小的，导致面积增大；移动大的，面积一定减小。

### 15. 三数之和

不会

### 19. 删除链表的倒数第 N 个结点

前后指针，相差n。

### 75. 颜色分类

对撞指针。如果当前指针分别与左右端交换

### 33. 搜索旋转排序数组

二分查找。根据`nums[mid]<nums[right]` 判断左有序还是右边有序。

### 34. 在排序数组中查找元素的第一个和最后一个位置

不会

### 50. Pow(x, n)

n为奇数则乘x，否则ans*ans

### 162. 寻找峰值

二分查找，`mid 与 mid+1`相比。
画出折线图，然后尽量往最值靠近。

### 179. 最大数

不会

### 147. 对链表进行插入排序

重新看

### 148. 排序链表

重新看

### 56. 合并区间

贪心：根据区间的第一个数字排序，排序后进行贪心合并。

### 54. 螺旋矩阵

模拟方向。

```
direc=[right,down,left,up];
direc=[(0,1),(1,0),(0,-1),(-1,0)]
```

每次判断是否该换方向。以及记录已经访问过的，防止重复访问。

### 105. 从前序与中序遍历序列构造二叉树

分治。

构建根节点。

构建左子树

构建右子树。

base条件：

两个序列为空。
 vector<int> p1(pre.begin()+1,pre.begin()+1+j);

### 152. 乘积最大子数组

重新看

### 78. 子集

重新看

### 17. 电话号码的字母组合

动态规划。重新看

### 5. 最长回文子串

动态规划。

dp: s[left,right] 是否为回文串。
从长度列举，列举开头字符。

```
dp[left][right]=(dp[left+1][right-1])&(dp[left]==dp[right])
```

### 20. 有效的括号

用栈来解决。

如果是左括号，push

如果是右括号，看能否弹出，否则invalid。

### 62. 不同路径

动态规划

```
f[i][j]记作。从0，0 到i，j位置所用的不同路径数。
f[i][j]=f[i-1][j]+f[i][j-1]
```

### 91. 解码方法

重新看

### 139. 单词拆分

动态规划

```
dp[i] 记为s[0...i) 字符串是否可以被分割成功。  ]
dp[i]=dp[j]&& check(substr[j...i) );  ]
```

### 198. 打家劫舍

动态规划

```
dp[i]  记为偷[0...i]个房间获得的最大值。
dp[i]=max(dp[i-1],dp[i-2]+num[i]);
```

### 64. 最小路径和

动态规划

```c++
dp[i][j] 记为从(0,0)处出发到(i,j)处路径最小和。
dp[i][j]=min(dp[i-1][j],dp[i][j-1])+num[i][j];
```



### 120. 三角形最小路径和

动态规划

```c++
dp[i][j] 记为从(0,0)到位置(i,j)的最小路径和。
//非边缘节点。
dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+num[i][j]
// 对角线节点 j=i时候dp[i-1][i]不存在
dp[i][i]=dp[i-1][i-1]+num[i][j]
// 左边缘节点j=0,dp[i-1][-1]不存在
dp[i][0]=dp[i-1][j]+num[i][j]
```

### 3. 无重复字符的最长子串

从字符串开始往set中放入。

放入随后的字符，当放入到发现重复字符时候，删除首字符。

### 48. 旋转图像

不会

### 73. 矩阵置零

1. 建立一个同等大小的矩阵。记录每行每列的置零情况。

2. 先检查0行，0列是否需要置零。

   从1行，1列检查是否需要置零，如果需要则在边缘端记录。

   从1行，1列进行检查，置零。

   将0行，0列置零。

### 128. 最长连续序列

可以先将数据放到set里面。从最小的数字开始找，找到之后从最小数字递增找。
先找到最小元素
### 79. 单词搜索

回溯法：

```c++
void backstrace(solution){
    if(solution){
        get(solution)
        return;
    }
    for (next_solution in solutions_list){
        if (next_solution){
            place_variable;
            backtrace(next_solution);
            remove_variabel;
        }
    }
}
```

该题目需要定义一个`visited`矩阵，记录是否到访过。套用上述模板。

```c++
visited[i][j]=true
backtrace()
visited[i][j]=false
```

### 189. 旋转数组

1. 创建一个同样大小的数组，从第k个元素开始赋值。
2. 创建一个数组，n-k个。复制一段元素。
3. 对于每个元素，算出其应当在的位置，与那个元素交换。由于可能会发生回到起点但是元素还未遍历完的现象。所以需要外层的loop(gcd(n,k))。



### 36. 有效的数独

哈希表：建立三组unordered_set。一次循环放入。

### 49. 字母异位词分组

哈希表：归类问题。

### 138. 复制带随机指针的链表

建立映射

```c
mp[it]->random=mp[it->random];
```

### 22. 括号生成

回溯法：

```c
base 条件
左括号个数<n;
右括号个数<n;

总的括号个数=2n
```

### 46. 全排列

回溯。重看过程。

### 131. 分割回文串

回溯。如果当前子串是回文，则进行下一步的回溯。

### 98. 验证二叉搜索树

分治：

```c
ist(TreeNode* no,long long low,long long high)
```

判断左右子树的和。

### 102. 二叉树的层序遍历

队列。先放进的先拿出，拿出后依次放入左、右子树。再拿出。
双层循环，size=q.size();

### 200
dfs