本文档用来记录 **leetcode** 前200题目中的easy与medium题目的思路。

### 1.两数之和

如果有序可以使用对撞双指针。复杂度位O(n)+O(n^2);

如果无序，使用哈希表。

一种办法是先全部插入哈希表，然后再搜索。复杂度位O(n)+O(1);注意的是数组中字符重复，hash的value需要使用vector；

二种办法是每次插入前查找哈希种是否存在 target-x。这样避免了上述的哈希值为vector。

### 2  两数相加

创建新链表dummy。逐位相加，新节点的和为 sum%10, 进位为sum/10。

循环判断条件为两个链表都为空。

如果最后的进位仍然大于0，创建新节点。

### 3. 无重复字符的最长子串

滑动窗口。

从字符串开头往一个unordered_set中放入。

从该字符随后的字符开始依次放入，当放入到发现重复字符时候，删除首字符。

第一层循环记录的为left边界。

第二层循环记录的是right边界。所以每次第二层循环退出时候。先进行统计，然后删除left元素。

trick：left边界与right边界均从0开始。

### 5. 最长回文子串

动态规划。

设 dp [ left ] [right] 表示 s[left,right] 是否为回文串。

因为：单个字母是回文。所以 dp [i] [i]=true;

loop: 字符串长度：2--Len。

loop：left：0--len：

​	求得right。

​    有以下情形：

​	right不合法，

​    right合法：

​		left字符与right字符不相等。false。

​       left字符与right字符相等。

​				长度为2,  true.

​				长度大于2. 

```c
dp[left][right]=(dp[left+1][right-1])&(dp[left]==dp[right])
```



每次循环结束做一些统计。

trick： 递推长度计算right。



### 7. 整数反转

每次求出最后一位，然后再加入新的值。

注意：每次加入之前判断是否溢出。要求新的值 属于(INT_MIN,  INT_MAX);

### 9. 回文数

构造出整数的右半部分。

构造办法同整数反转，当 x<=right时候停止构造。

判断right与x是否相等或者差一个倍数。

trick：右半部分。

### 11. 盛最多水的容器

对撞指针，

loop：

移动数值小的一边，导致面积增大；

当左右重合时候面积为0.退出loop。

统计面积即可。

### 13. 罗马数字转整数

从后往前遍历。如果pre小于cur，则合并为一组。游标多移动一次。

否则加当前字符。

退出时候看看游标是否指向0位置元素。

trick：记录游标的最后位置。

### 14. 最长公共前缀

贪心。

循环：1--len

求出当前字符串与当前prefix的交集。从而得到公共字符串。

### 15. 三数之和

先排序。

loop： first

loop： second

loop：判断third是否过大。否则左移动。



trick： 判断数值是否重复。

第三层循环时候注意second不能与third重合。



复杂度为：
$$
O(N^{2}).
$$
因为：双指针情况下，左右指针总共移动N次，因此为`O(N)`. 排序的复杂度为`O(NlogN)`. 所以和为平方。

```c
loop:
	loop:
		//从后往前找一个值，直到三数之和<=0.
```





### 258. 各位相加

循环，判断和是否属于[0,10]

### 121 买卖股票的最佳时机

双层循环，判断利润是否变大。



### 1221. 分割平衡字符串

贪心，如果可以分割则分割。` is_right++,is_right-- `

### 1725. 可以形成最大正方形的矩形数目

求出每个矩形的边长最小值，获得maxlen个数。

### 1710. 卡车上的最大单元数

按照能装的最大单元数排序，将单元数由大到小取值。获取总数。

### 1716.计算力扣银行的钱

找规律，直接计算即可。

### 944. 删列造序

贪心，只需要关注当前节点与前置节点即可。

### 1518. 换酒问题

```c++
add=left/numExchange;
left=(left%numExchange+add);
sum+=add;
```

### 1046. 最后一块石头的重量

1. 排序。删除，终止条件为看最前面两个数是否为0，或者增加一个标志，记录当前的数据量。
2. 使用最大堆。如果`a>b`, 则push进入`a-b`. 当队列中元素个数<2时候退出。

### 860. 柠檬水找零

贪心，模拟，找零找最大的面值。

### 455 分发饼干

贪心：排序，大饼干给胃口大的孩子。否则这个孩子得不到饼干。

### 392. 判断子序列

忘记了。待思考

### 70. 爬楼梯

动态规划：`f(n)=f(n-1)+f(n-2)`

### 122. 买卖股票的最佳时机 II

当当前卖掉股票是正利润时候，则卖掉。

### 26. 删除有序数组中的重复项

双指针：a指向当前待填充元素，b指向当前移动的元素。

### 27. 移除元素

双指针：a指向待填充元素，b指向当前移动的元素`(!=val)`

### 35. 搜索插入位置

二分查找。

### 53. 最大子序和

贪心：如果之前序列和为正，则加入当前元素，否则序列和`:=`当前元素。

### 66. 加一

数组遍历：从个位加到最高位，注意在数组头插入。

```c
vector <int>::iterator begin = digits.begin();
digits.insert(begin,add);
```

### 118. 杨辉三角

数组遍历：记录前面一行，

```
int sum=pre[j]+pre[j+1];
t[j+1]=sum;
```

### 167. 两数之和 II - 输入有序数组

二分查找。判断`sum=numbers[left]+numbers[right];`与`target` .

### 169. 多数元素

哈希表。

```c++
counts.insert(make_pair(nums[i],1));
```

### 28. 实现 strStr()

字符串匹配。可用KMP算法（待看）。

### 141. 环形链表

快慢指针。

### 125. 验证回文串

对撞指针。过滤用`isalnum`

### 21. 合并两个有序链表

技巧：创建一个头节点。`  ListNode* preHead = new ListNode(-1); `, 循环串节点。

### 83. 删除排序链表中的重复元素

一次遍历：只要next节点与当前节点相等，则删除next节点。

或者双指针。左右指针。

### 100. 相同的树

递归，分治。base条件：

```c++
if(p==nullptr && q!=nullptr){
            return false;
        }else if(p!=nullptr && q==nullptr){
            return false;
        }else if(p==nullptr && q==nullptr){
            return true;
        }
        if (p->val!=q->val){
            return false;
}

```

### 101. 对称二叉树

递归，分治。

### 104. 二叉树的最大深度

递归。

base条件

```C++
if(root==nullptr){
            return 0;
}
```

### 110. 平衡二叉树

递归，分治。判断左子树与右子树是否平衡。

### 112. 路径总和

递归，分治。左子树与右子树是否存在`target-root->val`

### 69. x 的平方根

二分查找。比较ret与mid的关系。

```c
int ret=x/mid;
```

### 7. 整数反转

注意溢出。

### 9. 回文数

右半个数的构造办法。

```c
right=right*10+x%10;
x=x/10;
```

### 13. 罗马数字转整数

从后往前遍历。如果pre小于cur，则合并为一组。

### 67. 二进制求和

反转字符串，然后逐位相加。技巧 `b.at(i)`,不用`b[i]`;

### 168. Excel表列名称

假设
$$
x=a_{0}*26^{0}\quad+ a_{1}*26^{1}\quad+... \quad+ a_{n}*26^{n};
$$
对`x%26` 即可得到 
$$
a_{0}
$$
再对`x/26`即可得到
$$
x=a_{1}*26^{0}\quad+... \quad+ a_{n}*26^{n-1};
$$
 但是由于
$$
26=26*26^{0}
$$
所以导致`x/26=1`,那么有
$$
x=1+a_{1}*26^{0}\quad+... \quad+ a_{n}*26^{n-1};
$$
所以此时要`x-1`

### 171. Excel表列序号

26进制。

### 172. 阶乘后的零

求2与5的个数最小值。

### 136. 只出现一次的数字

异或运算具有结合律，交换律。

```
a^a=0
0^b=b
```

### 190. 颠倒二进制位

左移动为`i+=(k<<(31-j));`位。

### 191. 位1的个数

位运算。

### 58. 最后一个单词的长度

注意后端的空格即可。

### 88. 合并两个有序数组

待定

### 38. 外观数列

递归.

### 111. 二叉树的最小深度

左右子树的最小深度.

### 119. 杨辉三角 II

递归.

### 160. 相交链表

先各自遍历,到尾部后,交换遍历.

### 55. 跳跃游戏

在每一步跳到最远,记录坐标.

